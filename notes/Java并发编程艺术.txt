1.Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式执行的，整个通信过程对程序员完全透明。

2.在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程间共享。
  Java线程之间的通信由Java内存模型（JMM）控制，JMM觉得一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了

线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享

变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

3.在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型：a.编译器优化的重排序。编译器在不改变单线程程

序语义的前提下，可以重新安排语句的执行顺序。b.指令级并行的重排序。现代处理器采用了志林级并行技术来将多指令重叠执行。如果不存在数

据依赖性，处理器可以改变语句对应机器指令的执行顺序。c.内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看

山去可能是在乱序执行。

4.JSR-133内存模型中的happens-before并不意味着前一个操作必须要在后一个操作之前执行，仅仅是要求前一个操作的结果对后一个操作可见，

且前一个操作按顺序排在第二个操作之前。

5.两个操作访问同一个变量，且其中一个为写操作，此时这两个操作就存在数据依赖性。编译器和处理器在重排序时，会遵守数据依赖性，不会改

变两个操作的执行顺序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的

数据依赖性不被编译器和处理器考虑。
  注：多线程一定要注意重排序。

6.当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。此时，对其他线程可见。



















